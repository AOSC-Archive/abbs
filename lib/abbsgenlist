#!/bin/bash
. $ABBS/env/base.sh

abrequire pm arch

if [ ! "$CROSS" = "" ] && [ "$CROSS" != "$ARCH" ]; then
	pm_chroot /var/ab/cross-root/"$CROSS"
fi

##abbs_deps _FULLY_QUALIFIED_NAME_
##@return{abset} abbs_deps: Shallow dependencies in "entirely qualified names"
##                          (i.e. abstraction leak for sub-builds; FIXME)
abbs_deps(){
	((__abbs_gen_list_recurse__)) || abset_loc deps # warning?
	abset_new abbs_deps
	local __abbs_gen_list_recurse__=1
	local i

	local PKGDEP BUILDDEP # TODO: local all defines
	# Process [num]-* too -- this sounds silly but that's how it works
	for i in "$ABBS/repo/$1"/*/
	do
		# cycle detection
		if [[ ${deps["$i"]} == VISITED ]]; then
			abinfo "$i already expanded. Cycle?"
			continue
		fi
		deps["$i"]='VISITED'

		[ -d "$i" ] || continue
		. "$i"/defines
		# names+=("$PKGNAME")
		abset_add abbs_deps $PKGDEP $BUILDDEP # split; deprecate@ab3-2.x
	done
	# abset_del abbs_deps "${names[@]}"
}

# input is fully qualified name?
abbs_gen_list(){
	# make sure we don't curse over and over
	if ((!__abbs_gen_list_recurse__)); then
		abset_loc deps
		local __abbs_gen_list_top__=1
	fi
	abset_loc current_level_deps
	local __abbs_gen_list_recurse__=1

	abbs_deps "$@"
	abset_add deps "${!abbs_deps[@]}"

	# move the returned set to a local set
	abset_add current_level_deps "${!abbs_deps[@]}"
	unset abbs_deps

	local j
	for j in "${!current_level_deps[@]}"; do
		if pm_exists "$j"
		then
			continue
		fi
		if pm_repoinstall "$DEP" >/dev/tty </dev/tty
		then
			continue
		fi

		# check for build
		SOURCE="`abbsfindsource "$j"`"
		if (($?)) || [[ ! -n $SOURCE ]]; then
			aberr "Cannot find build spec for package $j"
			return 1
		else
			# redo the curse
			__abbs_gen_list_top__=0 abbs_gen_list "$j" || return
		fi
	done

	# transitional pipable return
	if ((__abbs_gen_list_top__)); then
		printf '%s\n' "${!deps[@]}"
	fi
}
