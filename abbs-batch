#! /bin/sh
# Naive ab3-like batch.
# USAGE
# 	abbs-batch [batchfile=stdin] [startfrom=0]
# ARGUMENTS
#	batchfile	Defines where to read from.
#	startfrom	Omits the first NUM packages.
exec 66 <> "${1-&0}"
# SYNTAX
# #+This is a comment that would be printed.
# # This is just a comment.
#
# # We do nothing to a blank line.
# @foo/optional_package
# # Packages can be optional, when they are prefixed with '@'.
# foo/essential_package
# # All other packages are essential. So the script stops when it fails.
# quite_a_long_name_yahoo/\
# Oh-my-fried-god
# # sh's read allows you to backslash-escape something.

abbs_batch_error=''
abbs_batch_count=0
abbs_batch_start=${2-0}

# Look, this is an underline, not a hyphen.
abbs_build(){
	(( ++abbs_batch_count < abbs_batch_start )) && continue
	abbs-build "$@"
}

# Butt-wiper -- something is going toooo long for us.
abbs_batch_butt(){
	local _ret=$?
	local errstr="$abbs_batch_pkg	$_ret	$abbs_batch_count"
	echo "$1	$errstr">&2
	abbs_batch_error="$abbs_batch_error
$errstr"
	return $_ret
}
	
while read -u 66 abbs_batch_pkg; do
	case "$abbs_batch_pkg" in
		('#+'*)	echo "${abbs_batch_pkg##'#+'}";;
		('#'*|'')	:;;
		('@'*)	abbs_build "$abbs_batch_pkg" ||
			abbs_batch_butt E;;
		(*)	abbs_build "$abbs_batch_pkg" ||
			abbs_batch_butt F ||
			exit $?
	esac
done

if [ "$abbs_batch_errors" ]; then
	echo "Failures during build:
$abbs_batch_errors"
else
	echo "All packages okay."
fi
